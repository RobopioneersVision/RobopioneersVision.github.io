<hr>
<p>title: 基础算法——搜索.md<br>toc: true<br>date: 2021-12-22 09:25:00</p>
<hr>
<h1 id="基础算法——搜索"><a href="#基础算法——搜索" class="headerlink" title="基础算法——搜索"></a>基础算法——搜索</h1><p>January 10, 2021 @KeYuan Liu </p>
<p>本文代码如无特殊说明，全部为伪代码</p>
<h1 id="1-递归函数"><a href="#1-递归函数" class="headerlink" title="1. 递归函数"></a>1. 递归函数</h1><ul>
<li>在一个函数中再次调用自己的行为叫做递归</li>
<li>这样的函数叫做递归函数</li>
</ul>
<h3 id="eg：求n的阶乘"><a href="#eg：求n的阶乘" class="headerlink" title="eg：求n的阶乘"></a>eg：求n的阶乘</h3><pre><code class="cpp">int f(int n)
{
    if(n==0)
        return 1;
    return f(n-1)*n;
}
</code></pre>
<p><strong>注意</strong> : 在编写一个递归函数时，函数的停止条件是必须的。没有终止条件的递归函数会无休止的运行下去。程序就会失控崩溃了。</p>
<hr>
<h3 id="接下来，我们想一下斐波那契数列。请读者自己思考一下。其实很简单。"><a href="#接下来，我们想一下斐波那契数列。请读者自己思考一下。其实很简单。" class="headerlink" title="接下来，我们想一下斐波那契数列。请读者自己思考一下。其实很简单。"></a>接下来，我们想一下<a href="https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin">斐波那契数列</a>。<del>请读者自己思考一下</del>。其实很简单。</h3><pre><code class="cpp">int f(int n)
{
    if(n&lt;=1)
        return n;
  return f(n-1)+f(n-2);
}
</code></pre>
<p>可以证明，这个函数的复杂度是$2^n$。指数级别的复杂度是相当之高的。对此，我们要思考，如何简化复杂度。</p>
<h3 id="在f中，如果n是一定的，无论调用多少次，都会得到相同的答案，不如我们尝试把他们用数组存起来，这样就可以计算一次后快速调用，优化之前的算法。"><a href="#在f中，如果n是一定的，无论调用多少次，都会得到相同的答案，不如我们尝试把他们用数组存起来，这样就可以计算一次后快速调用，优化之前的算法。" class="headerlink" title="在f中，如果n是一定的，无论调用多少次，都会得到相同的答案，不如我们尝试把他们用数组存起来，这样就可以计算一次后快速调用，优化之前的算法。"></a>在f中，如果n是一定的，无论调用多少次，都会得到相同的答案，不如我们尝试把他们用数组存起来，这样就可以计算一次后快速调用，优化之前的算法。</h3><ul>
<li>这种方法叫做记忆化搜索</li>
</ul>
<pre><code class="cpp">a[n] //记忆化数组用于存结果
int f(int n)
{
    if(n&lt;=1)
        return n;
    if(a[n]!=0)
        return a[n];
    return a[n]=f(n-1)+f(n-2);
}
</code></pre>
<h1 id="2-栈（Stack）"><a href="#2-栈（Stack）" class="headerlink" title="2. 栈（Stack）"></a>2. 栈（Stack）</h1><p>Stack是一种可以支持pop和push两种操作的数据结构。栈是一种先入后出的简单结构。</p>
<ul>
<li>push： 在栈的顶部加入一个元素</li>
<li>pop：  在栈的顶部删除一个元素</li>
<li>top：   返回栈顶的元素</li>
</ul>
<pre><code class="cpp">#include&lt;stack&gt;

stack&lt;int&gt; q;// stack&lt;数据类型&gt; 名称；
int main()
{
    q.push(1);//1
    q.push(2);//1 2
    cout&lt;&lt;q.top();//2
    q.pop();
    cout&lt;&lt;q.top();//1
}
</code></pre>
<p>函数的调用过程是通过栈来实现的。因此递归函数的递归过程也可以改成栈上操作。</p>
<h1 id="3-队列（Queue）"><a href="#3-队列（Queue）" class="headerlink" title="3. 队列（Queue）"></a>3. 队列（Queue）</h1><p>Queue与Stack类似，都支持pop和push两种操作。但是pop的含义不同了。这里的pop是pop最先进来的元素</p>
<ul>
<li>pop:   删除左边的元素</li>
<li>push：在右边加入新的元素</li>
<li>front：返回左边的第一个元素</li>
</ul>
<pre><code class="cpp">#include&lt;queue&gt;

queue&lt;int&gt; q; // queue&lt;数据类型&gt; 名称；
int main()
{
    q.push(1);//1
    q.push(2);// 1 2
    q.pop();//2
    q.push(3);//2 3
    cout&lt;&lt;q.front();//2
}
</code></pre>
<hr>
<p>画张图更好的解释以上两种数据结构？（左侧是栈，右侧是队列）</p>
<p><img src="https://i.loli.net/2021/01/10/NzyV2i84fU5w1RM.jpg" alt="https://i.loli.net/2021/01/10/NzyV2i84fU5w1RM.jpg"></p>
<hr>
<p>介绍完了以上基本内容，接下来就要讲解一下<del>电风扇</del> （dfs） <del>蝙蝠衫</del> （bfs）</p>
<h1 id="4-深度优先搜索（DFS）"><a href="#4-深度优先搜索（DFS）" class="headerlink" title="4. 深度优先搜索（DFS）"></a>4. 深度优先搜索（DFS）</h1><pre><code>  深度优先搜索，搜索的手段之一。它是从某个状态开始，不断的转移状态直到无法转移，然后退到前一步状态，继续转移到其他状态。直到找到最终的解。（~~时间复杂度巨高，往往是没有更好的办法的办法~~） 。优点是能遍历出所有的状态。

 举个🌰，[数独](https://baike.baidu.com/item/数独/74847?fr=aladdin)大家都玩过吧。首先在一个格子里填入一个合适的数，然后继续向下一个格子里填数直到发现某个格子无解时停止，然后放弃前一个格子选的数字改用其他数字（这就是回溯！）
</code></pre>
<p>一直重复这样的操作直到填入的所有数都合法时退出。根据DFS的特点，递归函数是一个不错的选择。</p>
<h3 id="eg：部分和问题"><a href="#eg：部分和问题" class="headerlink" title="eg：部分和问题"></a>eg：部分和问题</h3><blockquote>
<p>给定整数A1 A2 …. An,判断是否可以从中选出若干个数，使他们的和恰好为k。（1≤n≤20  |An|,|k|≤ 10^8  ）</p>
</blockquote>
<p>~思</p>
<p>~考</p>
<p>~时</p>
<p>~间</p>
<p>~！</p>
<p>~！</p>
<h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><p>从第一个开始就要决定它是否要被选。复杂度是2^n 。最后决定完n个数的状态时（选或不选）。答案就出来了。</p>
<pre><code class="cpp">bool dfs(int poi,int sum)//poi 当前的位置，sum 目前的和
{
    if(poi==n) return sum==k;
    if(dfs(poi+1,sum)) return 1;//下一个不选
    if(dfs(poi+1,sum+a[poi])) return 1;//下一个选
    return 0;//无论是否选不选都不能满足sum==k的条件就返回0
}
</code></pre>
<p>DFS有时候还是一个比较有用的算法。虽然复杂度很高，但是枚举出所有状态也是很棒的。（其实它悄悄的用了栈的知识）</p>
<h1 id="5-宽度优先搜索（BFS）"><a href="#5-宽度优先搜索（BFS）" class="headerlink" title="5. 宽度优先搜索（BFS）"></a>5. 宽度优先搜索（BFS）</h1><p>BFS和DFS有很多类似的地方，比如说从某个状态出发可以抵达所有可到达的装态。但也有很多不同的地方（<del>谁叫他是BFS呢</del>）。首先最不相同的是搜索的顺序（俗话说的好，搜索顺序棒，O（n）出答案）</p>
<p>BFS总是优先搜索距离初始状态最近的状态。就像一只网一样。先向外拓展转移一次的状态，然后在从每一个一次状态中转移到第二次状态。 对于一种状态BFS只访问一次所以复杂度大大降低。</p>
<p><img src="%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2/1.png"></p>
<p>此处我们用队列来解决问题。（先进来的先处理，后进来的后处理）</p>
<p>一般的代码结构是这样的</p>
<pre><code class="cpp">#include&lt;queue&gt;
queue&lt;int&gt;q;//queue&lt;数据类型&gt; 名称；
void bfs(int x)
{
    q.push(x);
    while(!q.empty())
    {
        int f=q.front();
        q.pop();
        /*
        *此处对f进行操作
        *满足条件的加入队列
        */
    }
}
</code></pre>
<p>在求解最短路问题时，bfs的这种思想还是比较有用的。但是状态数和内存空间成正比。而dfs是与最大深度成正比。所以说两种有利有弊吧。</p>
<hr>
<p>当然搜索不只这些，还有很多高级操作。这里只稍微提及一下<strong>剪枝</strong></p>
<p>在dfs过程中，有一些早已明确的知道从当前状态无法转移到合法解。从这种情况下再继续搜索是毫无意义的。不如直接跳过。这种方法就叫做<strong>剪枝。</strong></p>
<p>回想一下在dfs中的例题，当sum&gt;k时无论如何都不可能得到答案，所以后面的就没有必要搜索了。</p>
<p>以上就是我所分享的简单搜索。</p>
